# CS452 Project Rosalina Delwiche and Holly Rossmann

## Game Name
Shape Mania 

## Goal
 You are the octagon and your goal is to collect all 5 circles within 30 seconds, under  certain conditions by moving left, right, up, and down. However, beware of the tumbling red octagons! Crossing paths with these means immediate death. Anytime your hexagon touches a circle, rectangle, or square, it dissapears and you receive the effects associated with the object.  There are two different ways you can change your speed, one good and one bad. The triangles serve as powerups. By crossing paths with a triangle, your speed is increased. By crossing paths with a rectangle, you a are put in a five second time out in which your movement is paused. After the five seconds is up, you may resume movement. The circle is your main focus, each circle counts as 1 point. In order to win, you must get to 5 points before the 30 seconds is up without getting hit by a tumbling red octagon. The time remaining is displayed as "Game will end in:" with the seconds listed. Additionally, the score is below which is updated each time you gain a point. After the 30 seconds is up, your game status will display next to the score indicating whether you have won or lost. 

## Game Control
 You only have the power to control the movement of the hexagon, the biggest object on the canvas. The keys to control it are the following:
    a   : move left 
    d   : move right
    w   : move up
    s   : move down
    ** You must press the corresponding key each time movement is desired, and moving beyond the canvas is not allowed **
    r   : to restart the game from the beginning


## Implementation
    In total, our game contains 5 different types of shapes. The main one is the hexagon, which is controlled by keys a, d, w, and s with the movement defined above in "Game Controls". Next, there are five circles, two triangles, one square, and three octagons.  To implement, we first started working on the html. Within the html, there are div containers for both the score and the time remaining. The timer countdown is performed within the html itself by using setInterval. Onload in the html is defined by init() and onkeydown is defined as moveSquareKeys(event). Init() and moveSquareKeys() are defined in "project1.js". To set up "project1.js", we first declared global variables for the x position, y position, and an array containing the points of the vertex for each object shown. Init() first sets the values of the tx and ty positions of each object, intializes an init shader for each type of object, and draws the shapes. The initshader function for each type of object uses the corresponding fragment shader defined in the html file. These fragment shaders are written with a script and contain a main function which set the fragment color, allowing us to specify the color of the object. With 5 types of objects, there are five fragment shaders, each set to a different rgba (red, green, blue, alpha) color. The main shape, the hexagon is drawn first, then the circles, octagons, triangles, and lastly squares. Each shape is drawn by specifying the points of the object into an array, creating a buffer, binding the buffer, and by using STATIC_DRAW. The circle is drawn with a finite set of points, 64 to be exact. As mentioned, onkeydown executes moveSquareKeys(). moveSquareKeys() manipulates the x and y values of the hexagon in order to create movement by the offset of .1. The x and y values are written to be between -1 and 1, so that the hexagon can not entirely disappear from the canvas. After a key press of a, s, d, or w, the position of the hexagon is thus updated. After the draw, render() is repeatedly called using requestAnimFrame. Within render, the object is animated, the score is calculated, and it checks to see if the hexagon has encountered an object and handles it accordingly. The functions isCloseToAnt(), isCloseToFruit(), powerChangeProximity(), are the ones that sense whether the hexagon has crossed paths with any of the objects. Within each of these functions it takes into consideration the x and y values of the hexagon in relation to the other shape. Since the x and y value of each object is generally defined as the center of the object, we created a way got a larger region of touch. This way the center point of each object does not have to match up with the center point of the other object. Rather, it is a region. This region is defined for the hexagon as tx +- .1 to ty +- 1, essentially creating a bounding box. This same idea is applied to the other shapes. If any of the points of the hexagon match up to any other shape, that means the shape has been touched by the hexagon. When touched, it sets a boolean corresponding to the object indicating it has been touched and render no longer draws that object. We also use these booleans to calculate the score, by summing up the booleans for each circle and writing to the html. When the square is touched, movement is stopped for 5 seconds by not allowing moveSquareKeys to fully execute until the time remaining left to the game is less than when the time out ends. The user is made known of the time out by displaying a message appended to the score. When a triangle is touched, the offset (aka speed) of the hexagon is increased by .1. If the hexagon touches the three tumbling octagons, the time immediately goes to 0 and displays a message that you have lost. If the time remaining is greater than 0, you have collected all 5 circles, and the hexagon has not touched a tumbling octagon, you have won! Upon winning, the game time goes to 0 and it displays you have won in the score. Lastly, whenever the user wishes to restart the game, they can press the r key which forces reload of the html and js. 


