CS452 Project Rosalina Delwiche and Holly Rossmann

Game Name:
Shape Mania 

Introduction & Goal:
 You are the octagon and your goal is to collect all 5 circles within 30 seconds, under  certain conditions by moving left, right, up, and down. However, beware of the tumbling purple octagons! Crossing paths with these means immediate death. Anytime your hexagon touches a circle, rectangle, or square, that object will dissapear and you receive the effects associated with the object. There are two different ways you can change your speed, one good and one bad. The triangles serve as powerups. By crossing paths with a triangle, your speed is increased. By crossing paths with a rectangle, you a are put in a five second time out in which your movement is paused. After the five seconds is up, you may resume movement. The circles are your main focus - each circle counts as 1 point. In order to win, you must get to 5 points within 30 seconds without getting hit by the octagons. The time remaining, in seconds, is displayed as "Game will end in:". Additionally, the score is found below the timer which is updated each time you gain a point. After the 30 seconds is up, your game status will display next to the score indicating whether you have won or lost. 

Game Controls:
 You only have the power to control the movement of the pink hexagon, the biggest object on the canvas. The keys to control it are the following:
    w   : move up
    a   : move left 
    s   : move down
    d   : move right
    ** The best method is to press the corresponding key each time movement is desired. You may hold down a key to move in a particular direction, but you will find that your movements may not be as precise. Moving completely beyond the canvas is not allowed **
    Addition, the following key allows you to reset the game and try again:
    r   : to restart the game from the beginning


Implementation:
 In total, our game contains 5 different types of shapes. The main one is the hexagon, which is controlled by keys w, a, s and d with the movement defined above in "Game Controls". Next, there are five circles (which give the user a point), two triangles (which increase the user's movement), one square (that pauses the user's movement), and three octagons (that end the game when touched). To implement, we first started working on the html. Within the html file, there are div containers for both the score and the time remaining. The timer countdown is performed within the html itself by using setInterval. Onload in the html is defined by init() and onkeydown is defined as moveSquareKeys(event). Init() and moveSquareKeys() are defined in "project1.js". To set up "project1.js", we first declared global variables for the x position, y position, and an array containing the points of the vertex for each object shown. Init() first sets the values of the tx and ty positions of each object, intializes an init shader for each type of object, and draws the shapes. The initshader function for each type of object uses the corresponding fragment shader defined in the html file. These fragment shaders are written with a script and contain a main function which set the fragment color, allowing us to specify the color of the object. With 5 types of objects, there are five fragment shaders, each set to a different rgba (red, green, blue, alpha) color. The main shape, the hexagon is drawn first, then the circles, octagons, triangles, and lastly squares. Each shape is drawn by specifying the points of the object into an array, creating a buffer, binding the buffer, and by using STATIC_DRAW. The circle is drawn with a finite set (64) of points. As mentioned, onkeydown executes moveSquareKeys(). moveSquareKeys() manipulates the x and y values of the hexagon in order to create movement by the offset of 0.1. The x and y values are specifically chosen so that the hexagon can not entirely disappear from the canvas based on their starting positions. After a key press of w, a, s, or d the position of the hexagon is updated. After the draw, render() is repeatedly called using requestAnimFrame. Within render, the object is animated, the score is calculated, and it checks to see if the hexagon has encountered an object and handles it accordingly. The functions isCloseToAnt(), isCloseToFruit(), powerChangeProximity(), are used to sense whether the hexagon has crossed paths with any of the objects. Within each of these functions it takes into consideration the x and y values of the hexagon in relation to the other shape. Since the x and y value of each object is generally defined as the center of the object, we created bounding boxes, which are larger, more general, regions of touch. This way, the center point of each object does not have to match up with the center point of the other object in order to count as being in contact. Rather, it is a region. This region is defined for the hexagon as tx +- 0.1 to ty +- 0.1, essentially creating a bounding box. This same idea is applied to the other shapes. If any of the points of the hexagon match up to any other shape, that means the shape has been touched by the hexagon. When touched, it sets a boolean corresponding to the object indicating it has been touched and render no longer draws that object. We also use these booleans to calculate the score, by summing up the booleans for each circle and writing to the html. When the square is touched, movement is stopped for 5 seconds by not allowing moveSquareKeys to fully execute until the time remaining left to the game is less than when the time out ends. The user is made known of the time out by displaying a message appended to the score. When a triangle is touched, the offset (aka speed) of the hexagon is increased by .1. If the hexagon touches any of the three tumbling octagons, the user is unable to move, the time immediately goes to 0 and displays a message that you have lost. If the time remaining is greater than 0, you have collected all 5 circles, and the hexagon has not touched a tumbling octagon, you have won! Upon winning, the game time goes to 0 and it displays a green message that you have won in the score. Lastly, whenever the user wishes to restart the game, they can press the r key which forces reload of the html and js. 


